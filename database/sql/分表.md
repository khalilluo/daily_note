### 原因
一般来说数据表写到2kw条数据之后，底层B+树的层级结构就可能会变高，不同层级的数据页一般都放在磁盘里不同的地方，换言之，磁盘IO就会增多，带来的便是查询性能变差。
于是，当我们单表需要管理的数据变得越来越多，就不得不考虑数据库**分表**。而这里的分表，分为**水平分表和垂直分表**


### 垂直分表
**垂直分表**的原理比较简单，一般就是把某几列拆成一个新表，这样单行数据就会变小，B+树里的单个数据页（固定16kb）内能放入的行数就会变多，从而使单表能放入更多的数据。


### 水平分表

##### 根据id范围分表
最好用的，是根据id范围进行分表。
我们假设每张分表能放2kw行数据。那user0就放主键id为1~2kw的数据。user1就放id为2kw+1 ~ 4kw，user2就放id为4kw+1 ~ 6kw， userN就放 2N kw+1 ~ 2(N+1)kw。

假设现在有条数据，id=3kw，将这个3kw除2kw = 1.5，向下取整得到1，那就可以得到这条数据属于user1表。于是去读写user1表就行了。这就完成了数据的路由逻辑，我们把这部分逻辑封装起来，放在数据库和业务代码之间。

这样。对于业务代码来说，它只知道自己在读写一张 user 表，根本不知道底下还分了那么多张小表。

对于数据库来说，它并不知道自己被分表了，它只知道有那么几张表，正好名字长得比较像而已。

这还只是在一个数据库里做分表，如果范围再搞大点，还能在多个数据库里做分表，这就是所谓的分库分表。

##### 根据id取模分表

比如一个id=31进来，我们一共分了5张表，分别是user0到user4。对31%5=1，取模得1，于是就能知道应该读写user1表。
优点当然是比较简单。而且读写数据都可以很均匀的分摊到每个分表上。

但缺点也比较明显，如果想要扩展表的个数，比如从5张表变成8张表。那同样还是id=31的数据，31%8 = 7，就需要读写user7这张表。跟原来就对不上了。

这就需要考虑数据迁移的问题。很头秃


#### 总结
-   mysql在单表数据过大时，查询性能会变差，因此当数据量变得巨大时，需要考虑水平分表。
-   水平分表需要选定一个分片键，一般选择主键，然后根据id进行取模，或者根据id的范围进行分表。
-   mysql水平分表后，对于非分片键字段的查询会有读扩散的问题，可以用普通索引列作分片键建一个新表，先查新表拿到id后再回到原表再查一次原表。这本质上是借鉴了倒排索引的思路。
-   如果想要支持更多维度的查询，可以监听mysql的binlog，将数据写入到es，提供近实时的查询能力。
-   当然，用tidb替换mysql也是个思路。tidb属实是个好东西，不少厂都拿它换个皮贴个标，做成自己的**自研数据库**，非常推荐大家学习一波。
-   不要做过早的优化，没事别上来就分100个表，很多时候真用不上。