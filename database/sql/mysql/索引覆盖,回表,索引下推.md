## 索引覆盖
### 概念
就是select的数据列只用从索引中就能够取得，不必从数据表中读取。比如innodb的辅助索引就包含所有的数据，不需要通过辅助索引树找到主键，再通过主键去主键索引树，此时extra 里一般都有 using index
- 索引按照索引列进行排序，顺序扫描比随机地从磁盘读取每一行(回表)要要快得多
- 索引记录通常小于全行大小，因此，如果只读取索引，可以极大地减少数据访问量，进而可以更好的利用缓存

### 使用索引进行排序
MySQL中，有两种方式生成有序结果集：一是使用filesort，二是按索引顺序扫描

利用索引进行排序操作是非常快的，而且可以利用同一索引同时进 行查找和排序操作。当索引的顺序与ORDER BY中的列顺序相同且所有的列是同一方向(全部升序或者全部降序)时，可以使用索引来排序，如果查询是连接多个表，仅当ORDER BY中的所有列都是第一个表的列时才会使用索引，其它情况都会使用filesort

## 回表
### 概念
我们可以通过二级索引找到B+树中的叶子结点，但是二级索引的叶子节点的内容并不全，只有索引列的值和主键值。我们需要拿着主键值再去聚簇索引（主键索引）的叶子节点中去拿到完整的用户记录，这个过程叫做回表

### 回表的代价
我们根据二级索引`name`字段查找二级索引的叶子节点的代价还是比较小的，原因有二：
1.  叶子节点所在的页通过双向链表进行关联，遍历的速度比较快；
2.  MySQL会尽量让同一个索引的叶子节点的数据页在磁盘空间中相邻，尽力避免随机IO

但是二级索引叶子节点中的主键id的排布就没有任何规律了，毕竟`name`索引是对`name`字段进行排序的。进行回表的时候，极有可能出现主键`id`所在的记录在聚簇索引叶子节点中反复横跳的情况（正如上图中回表的3条线表示的那样），也就是随机IO。如果目标数据页恰好在内存中的话效果倒也不会太差，但如果不在内存中，还要从磁盘中加载一个数据页的内容（16KB）到内存中，这个速度可就太慢了。

我们需要做的就是尽量地减少回表操作带来的损耗，总结起来就是两点：
1.  能不回表就不回；
2.  必须回表就减少回表的次数。

## 索引下推

