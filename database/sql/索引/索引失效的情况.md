```sql
CREATE TABLE `user_innodb` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  `gender` tinyint(1) DEFAULT NULL,
  `phone` varchar(11) DEFAULT NULL,
  PRIMARY KEY (`id`)，
  INDEX IDX_NAME_PHONE (name, phone)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

```

### 违反最左前缀原则
拿我们文章开始创建的联合索引为例，该联合索引的 B + 树数据页内的记录首先按照`name`字段进行排序，`name`字段相同的情况下，再按照`phone`字段进行排序。

```sql
-- 如果我们直接使用`phone`字段进行搜索，无法利用索引的顺序性。
EXPLAIN SELECT * FROM user_innodb WHERE phone = "13203398311";

-- 但是一旦加上`name`的搜索条件，就会使用到联合索引，而且不需要在意`name`在`WHERE`子句中的位置，因为查询优化器会帮我们优化
EXPLAIN SELECT * FROM user_innodb WHERE phone = "13203398311" AND name = '蝉沐风';
```
`
### 使用反向查询（!=, <>,NOT LIKE)
MySQL 在使用反向查询（!=, <>, NOT LIKE）的时候无法使用索引，会导致全表扫描，*覆盖索引除外*

### LIKE 以通配符开头
当使用`name LIKE '%沐风'`或者`name LIKE '%沐%'`这两种方式都会使索引失效，因为联合索引的 B + 树数据页内的记录首先按照`name`字段进行排序，这两种搜索方式不在意`name`字段的开头是什么，自然就无法使用索引，只能通过全表扫描的方式进行查询
但是使用通配符结尾就没有问题

``` sql
EXPLAIN SELECT * FROM user_innodb WHERE name LIKE '蝉沐%';
```

### 对索引列做任何操作
如果不是单纯使用索引列，而是对索引列做了其他操作，例如数值计算、使用函数、（手动或自动）类型转换等操作，会导致索引失效

### 使用函数
```sql
EXPLAIN SELECT * FROM user_innodb WHERE LEFT(name,3) = '蝉沐风';

-- MySQL8.0 新增了函数索引的功能，我们可以给函数作用之后的结果创建索引，使用以下语句
ALTER TABLE user_innodb ADD KEY IDX_NAME_LEFT ((left(name,3)));

-- 再次执行`EXPLAIN`语句，此时索引生效
```

### 使用表达式

```sql
EXPLAIN SELECT * FROM user_innodb WHERE id + 1 = 1100000;

-- 换一种方式，单独使用`id`，就能高效使用索引
EXPLAIN SELECT * FROM user_innodb WHERE id = 1100000 - 1;
```

### 使用类型转换
当索引字段类型为字符串时，使用数字类型进行搜索不会用到索引；而索引字段类型为数字类型时，使用字符串类型进行搜索会使用到索引。

### OR 连接
使用`OR`连接的查询语句，如果`OR`之前的条件列是索引列，但是`OR`之后的条件列不是索引列，则不会使用索引
```sql
EXPLAIN SELECT * FROM user_innodb WHERE id = 1099999 OR gender = 0;
```