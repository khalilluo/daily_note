
```shell
# 新建
git checkout -b [BRANCH_NAME] # 新建并切换
git branch [BRANCH_NAME] # 直接新建分支


# 切换分支
git checkout [BRANCH_NAME]


# 合并
git merge [BRANCH_NAME] # 将另外一个分支的代码，打到当前分支之后。
git rebase [BRANCH_NAME] # 不推荐，对代码进行比较，将本分支修改后的代码打到另外一个分支之后


# 删除，即使删除了分支等，也可以用 git reflogs 找回来_
git branch -d [BRANCH_NAME] # 已经合并到 master
git branch -D [BRANCH_NAME] # 该分支未合并到 master，强制删除


# 查看所有分支包括远程分支
git branch -a
# 默认会在本地创建一个和远程分支一样名称的分支，并与远程关联
git checkout -t origin/<branch>
# 先在本地建立一个分支，并切换到该分支，然后从远程分支上同步代码到该分支上，并建立关联
git checkout -b <branch> origin/<branch>


# 使用bash关联远程分支
git clone [仓库地址]
git branch -r | grep -v '\->' | while read remote; do git branch --track "${remote#origin/}" "$remote"; done
git fetch --all
git pull --all



# remote 默认为 origin； branch 默认为当前分支
git push [REMOTE] [BRANCH]

# 获取远程分支更新
git pull # 把代码更新到  workspace
git fetch # 把代码更新到 Local repository，可能需要通过 merge 再合并到 worksapce 一次。
```


### 远程仓库

Clone 之后会有一个默认的远程仓库为 origin，但如果还要增加别的远程仓库，就需要用到下面命令了：

```shell
git remote add [REMOTE_NAME] [URL] # 添加原创仓库
git fetch [REMOTE_NAME] # 获取远程仓库更新
git branch -a # 查看包括远程仓库以内的所有分支
git push [REMOTE_NAME] [BRANCH_NAME] # 推送到远程仓库
```

郑重警告：**永远不要对主线 master 分支执行 —force **`

`rebase` 通常情况下不推荐使用，因为 rebase 完下游分支，再从上游分支 merge 的时候会丢失分支合并的 commit，但是对于部分有 history mysophobia 的人来说，它是保持代码提交历史记录干净的神器，那个 Merge branch 'xxx' of [http://git.code.oa.com/xxx](https://link.zhihu.com/?target=http%3A//git.code.oa.com/xxx) into yyy 的 commit 看起来也挺讨厌的。

对于已经推到 remote repository 的 commit，是不建议 rebase 的，因为一旦 rebase 了，别人再 pull 就会出一大堆的冲突 conflict，而且基本没法修，通常情况下还是建议用 merge 稳妥一些。
PS: rebase 还有一个强大的功能是配合 --interactive 参数修改之前的补丁，具体自己查一下，但是改完了 push --force 上去，别人再 pull 回来出 conflict 是必然的，但是这招是修改 Github 上的 Pull request（后面有提到）必备技能


### 重命名tag
```shell
git tag newtag oldtag

# 删除local旧tag
git tag -d oldtag

# 删除remote旧tag
git push origin :refs/tags/oldtag
# git push origin --delete <tagname> 方式二

# 推送本地tag到remote
git push --tags
```


https://www.jianshu.com/p/89254fc4c5ab