## 信号-槽的”元调用”

信号-槽特殊的地方，是moc(元对象编译器)为其生成了一份”元信息”,可以通过QMetaObject::invokeMethod的方式调用

例如:

```cpp
//实例化一个tom对象
Tom tom;
//通过invok方式调用信号
QMetaObject::invokeMethod(&tom, "miao");

//实例化一个jerry对象
Jerry jerry;
//通过invok方式调用槽
QMetaObject::invokeMethod(&jerry, "runAway");
```

一般在知道如何声明qobject的场景，没必要多此一举用invoke。

在一些需要”运行期反射”的情况下(头文件都没有,只知道有这么个对象,和函数的名字)，invoke十分有用。

invokeMethod还可以带参数、可以获取返回值



## 信号和信号的参数

信号可以带参数，参数的类型，必须是元对象系统能够识别的类型, 即元类型。（元对象系统后面再细说）

## 注册元类型

Qt已经将大部分常用的基础类型，都注册进了元对象系统，可以在QMetaType类中看到。

通常写的继承于QObject的子类，本身已经附带了元信息，可以直接在信号-槽中使用。

不是继承于QObject的结构体、类等自定义类型，可以通过Q_DECLARE_METATYPE宏 和 qRegisterMetaType函数进行注册，之后就可以在信号-槽中使用。

例如：

```cpp
struct MyStruct
{
    int i;
    ...
};

Q_DECLARE_METATYPE(MyStruct)
```

或者带命名空间的：

```cpp
namespace MyNamespace
{
    ...
}

Q_DECLARE_METATYPE(MyNamespace::MyStruct)
```

这里说明一下细节，Q_DECLARE_METATYPE宏声明过后，只是生成了元信息，可以被QVariant识别，还不能

用于队列方式的信号、槽，需要用qRegisterMetaType进行注册。而qRegisterMetaType要求”全定义”，也就是

提供类的”复制构造函数”和”赋值操作符”。

前面那种简单类型，C++编译器默认提供浅拷贝的”复制构造函数”和”赋值操作符”实现，可以直接用。

```cpp
struct MyStruct
{
    int i;
};
```

而复杂一些的类，就要提供”全定义”。

(顺带一提，信号的参数可以是任意注册过的对象，而C++11的lambda、std::bind也是对象，只要注册过，也是可以通过信号参数发送出去的。)





各种信号槽链接的方式对后续的调用 效率没影响，Qt5后的connect可以连接到普通函数及普通成员函数，但这种连接不支持connect类型，可以看成是之间的函数调用





### functor式

### 关于functor

问: 什么是functor？functor有什么用?

答: 在C++11之前, Qt通过自己的实现来推导函数指针及其参数，即QtPrivate::FunctionPointer, 用来处理信号-槽的连接。

C++11带来了lambda, 以及std::bind和std::function, std::function本身可以存储lambda、std::bind以及FunctionPointer。

这时候Qt已有的connect(4)、connect(5)、connect(6)是可以支持FunctionPointer的,而新出现的lambda以及std::bind是不支持的，

QtPrivate::FunctionPointer推导不出这些类型。所以Qt把这些不支持的新类型(主要是lambda和std::bind)称为functor(文档和源码都这么命名)，

并增加了connect(7)和connect(8)以支持functor。

### functor

functor式写法，声明如下：

```cpp
//connect(7) 连接信号到任意functor
   template <typename Func1, typename Func2>
   static inline typename std::enable_if<QtPrivate::FunctionPointer<Func2>::ArgumentCount == -1, QMetaObject::Connection>::type
           connect(const typename QtPrivate::FunctionPointer<Func1>::Object *sender, Func1 signal, Func2 slot);
		
//connect(8) 连接信号到任意functor。比(7)多一个context,可以设置连接类型
template <typename Func1, typename Func2>
   static inline typename std::enable_if<QtPrivate::FunctionPointer<Func2>::ArgumentCount == -1, QMetaObject::Connection>::type
           connect(const typename QtPrivate::FunctionPointer<Func1>::Object *sender, Func1 signal, const QObject *context, Func2 slot,
                   Qt::ConnectionType type = Qt::AutoConnection);
```

connect(7)可以连接信号到任意lambda、std::bind上。

connect(8)是对(7)的重载，增加了一个context对象代替reveicer对象的作用。这种连接是可以设置连接类型的。



### functor

A线程中写connect，让B线程中的信号连到C线程的槽中，希望C的槽在C中执行。

这种情况要明确指定QueuedConnection，不写的话按照Auto处理，C中的槽会在A中执行。

例2-跨线程DirectConnection

(这种用法在Qml的渲染引擎SceneGraph中比较常见)。

A线程为内部代码，不能修改，一些特定的节点会有信号发出。

B线程为用户代码，有一些功能函数，希望在A线程中去执行。

这种情况，将A的信号连接到B的函数，连接方式指定为DirectConnection，就可以把B的函数插入到A线程发信号的地方了。

效果类似于子类重载父类的函数。