## 原理

```cpp
// std::remove_reference<_Tp>是消除引用，得到原始类型t，所以以下重载的形参是左值引用和右值引用

template<typename _Tp>
constexpr _Tp&&forward(typename std::remove_reference<_Tp>::type& __t) noexcept{
	return static_cast<_Tp&&>(__t);
}

template<typename _Tp>
constexpr _Tp&&forward(typename std::remove_reference<_Tp>::type&& __t)noexcept{
	static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument substituting _Tp is an lvalue reference type");
	return static_cast<_Tp&&>(__t);
}

/*
在这份实现中，std::remove_reference的功能是消除类型中的引用，而std::is_lvalue_reference用于检查类型推导是否正确，在std::forward的第二个实现中检查了接收到的值确实是一个左值，进而体现了坍缩规则。

当std::forward接受左值时，_Tp被推导为左值，所以返回值为左值；而当其接受右值时，_Tp被推导为右值引用，则基于坍缩规则，返回值成了&& + &&的右值。可见std::forward的原理在于巧妙的利用了模板类型推导中产生的差异。
*/

```


## 应用
#### 调用移动构造/赋值

```cpp
class A {
    public:
        A(){
            std::cout << "A construct..." << std::endl;
            ptr_ = new int(100);
        }

        A(const A & a){
            std::cout << "A copy construct ..." << std::endl;
            ptr_ = new int();
            memcpy(ptr_, a.ptr_, sizeof(int));
        }
        
        A(A && a){
            std::cout << "A move construct ..." << std::endl;
            ptr_ = a.ptr_;
            a.ptr_ = nullptr;
        }

        ~A(){
            std::cout << "A deconstruct ..." << std::endl;
            if(ptr_){
                delete ptr_;
            }
        }

        A& operator=(const A & a) {
            std::cout << " A operator= ...." << std::endl;
            return *this;
        }


        int * getVal(){
            return ptr_;
        }
    private:
        int *ptr_;
};


template<typename T>
A* Create(T&& t){
	// 此处t是左值，就算t实参是右值也变变成左值，然后调用拷贝构造函数
   return new A(t);
}


// 内部是拷贝构造
A* a = Create(std::move(A()));


template<typename T>
A* CreatePerfect(T&& t){
	// 可以保持原始参数的类型，将实参从原来的类型为右值引用的左值，变成了本身就是右值引用
   return new A(std::forward<T>(t));
}

// 内部是移动构造
A* b = Create(std::move(A()));
```

#### 保留右值
```cpp
using Func = std::function<void()>;

void EventLoop::queueInLoop(const Func &cb)  
{  
    funcs_.enqueue(cb);  
    if (!isInLoopThread() || !looping_.load(std::memory_order_acquire))  
    {  
        wakeup();  
    }  
}  

// 右值引用执行的部分可能在调用完成后销毁，需要设法保留。
void EventLoop::queueInLoop(Func &&cb)  
{  
	// 如果不是std::function是lambda可以使用智能指针保留
    funcs_.enqueue(std::move(cb));  
    if (!isInLoopThread() || !looping_.load(std::memory_order_acquire))  
    {  
        wakeup();  
    }  
}

```