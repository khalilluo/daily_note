### override
override 关键字，可以避免派生类中忘记重写虚函数的错误。如果重新声明失败会有编译错误
```cpp
class Base {
public:
    virtual void mf1() const;
    virtual void mf2(int x);
    virtual void mf3() &;
    void mf4() const;    // error_1: not declared virtual in Base
};
 
class Derived: public Base {
public:
    virtual void mf1();                 // error_2: declared const in Base, but not in Derived.
    virtual void mf2(unsigned int x);   // error_3: takes an int in Base, but an unsigned int in Derived
    virtual void mf3() &&;              // error_4: lvalue-qualified in Base, but rvalue-qualified in Derived.
    void mf4() const;       
};
```

在派生类中，重写 (override) 继承自基类成员函数的实现 (implementation) 时，要满足如下条件：

  **一虚**：基类中，成员函数声明为虚拟的 (virtual)

  **二容**：基类和派生类中，成员函数的返回类型和异常规格 (exception specification) 必须兼容

  **四同**：基类和派生类中，成员函数名、形参类型、常量属性 (constness) 和 引用限定符 (reference qualifier) 必须完全相同

  如此多的限制条件，导致了虚函数重写如上述代码，极容易因为一个不小心而出错


### nodiscard
标记函数返回值或者类/结构体作为返回值不应该被忽略，否则会出现编译告警

``` c++
[[nodiscard]] int func(){return 1;}; // C++17
[[nodiscard("nodiscard_func_1")]] int func_1(){return 2;};  // C++20

func(); // warning
func_1(); // warning


struct [[nodiscard]] testStruct{};
class [[nodiscard]] testClass{};
enum class [[nodiscard]] testEnum{test1, test2};

testClass funcClass() {return {};}
testEnum funcEnum() {return testEnum::test1;}

void func()
{
	funcEnum(); // warning
}

funcClass(); //warning
```