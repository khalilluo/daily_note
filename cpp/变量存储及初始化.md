

```c++
C c;
void main()
{
    A*pa=new A();
    B b;
    static D d;
    delete pa;
}
```



变量自动初始化分为内置类型和类类型之分：

1.内置类型的自动初始化：程序中有一个数据区，用来存放**已初始化**全局变量，静态变量和常量，这部分增加了目标文件的大小；还有一个未初始化数据区(BSS)，用来存放**未初始化全局变量**，BSS的数据在程序开始执行之前被初始化为0或NULL，实际上BSS段数据在目标文件中只占一个符号位，编译器并没有给变量分配空间，“初始化为0”是指链接阶段才申请空间，并初始化。**局部** **非静态变量**未显示初始化时是一个随机值。

2.类类型的自动初始化：没什么特别的，无论是全局的还是局部的，都会调用默认构造函数进行初始化，有一点需要注意的是，当对象为全局作用域或者静态局部对象时，类的内置成员变量被初始化为0，而局部作用域时，内置成员变量不被自动初始化。



其中全局变量和静态局部变量时从 静态存储区中划分的空间，

二者的区别在于作用域的不同，全局变量作用域大于静态局部变量（只用于声明它的函数中），

而之所以是先释放 D 在释放 C的原因是， 程序中首先调用的是 C的构造函数，然后调用的是 D 的构造函数，析构函数的调用与构造函数的调用顺序刚好相反。

局部变量A 是通过 new 从系统的堆空间中分配的，程序运行结束之后，系统是不会自动回收分配给它的空间的，需要程序员手动调用 delete 来释放。

局部变量 B 对象的空间来自于系统的栈空间，在该方法执行结束就会由系统自动通过调用析构方法将其空间释放。

之所以是 先 A  后 B 是因为，B 是在函数执行到 结尾 "}" 的时候才调用析构函数， 而语句 delete a ; 位于函数结尾 "}" 之前。



```c++


class CTest
{
    public:
        CTest():m_chData(‘\0’),m_nData(0)
        {
        }
        virtual void mem_fun(){}
    private:
        char m_chData;
        int m_nData;
        static char s_chData;
};
char CTest::s_chData=’\0’;
```

若按4字节对齐sizeof(CTest)的值是12；

若按1字节对齐sizeof(CTest)的值是9

解释：

**在类中，如果什么都没有，则类占用1个字节，一旦类中有其他的占用空间成员，则这1个字节就不在计算之内，如一个类只有一个int则占用4字节而不是5字节。**

**如果只有成员函数，则还是只占用1个字节，因为类函数不占用空间**

**虚函数因为存在一个虚函数表，需要4个字节，数据成员对象如果为指针则为4字节，注意有字节对齐，如果为13字节，则进位到16字节空间。**

sizeof的本质是得到某个类型的大小，确切的来说就是当创建这个类型的一个对象(或变量)的时候，需要为它分配的空间的大小。而类也可以理解为类似于int、float这样的一种类型，当类中出现static成员变量的时候，static成员变量是存储在静态区当中的，它是一个共享的量，因此，在为这个类创建一个实例对象的时候，是无需再为static成员变量分配空间的，所以，这个类的实例对象所需要分配的空间是要排除static成员变量的，于是，当sizeof计算类的大小的时候会忽略static成员变量的大小