scoped_ptr跟auto_ptr类似，但无法被它那获取对象管理权。不转让对象控制器，都不能用作容器
void reset(T* P = 0)是重置scoped_ptr，让它重新管理P资源。但通常不应该被调用
scoped_ptr提供可以在bool语境自动转换的功能，测试是否管理的指针是否为空
用get函数获取的对象不能delete，否则scoped_ptr会对已删除的指针再做一次删除操作


shared_ptr离开作用域后，管理的资源便被释放。
用get获取指针后，use_count不会增加？？？
提供static_pointer_cast、const_pointer_cast和dynamic_pointer_cast替代标准的类型转换，使用标准类型转换可能会导致shared_ptr失效
用make_shared<T>(Args .. args)可以更高效的返回shared_ptr<T>对象,采用的是工厂模式。可以消除new的使用，函数参数最多10个

可以放置容器内，如vector<shared_ptr<string> >容器内的元素获取内存后会自动释放
用于桥接模式bridge？
用于工厂模式：使用一个基类，析构函数为protect，只有自己和子类可以访问析构。工厂函数返回子类对象，对象是用shared_ptr包装起来的，而且用get()获取的对象不能delete，因为析构是protect。

shared_ptr(T* p, D d)是另外一种构造函数，D为对象p删除器，即shared_ptr析构时用D(p)替代delete p。
D的要求通常是函数，行为如delete那样释放资源，且不能抛出异常。
shared_ptr<void>用删除器可以实现退出作用域调用任意函数，删除器参数需为void*
1、不要把一个原生指针给多个shared_ptr管理(用new构造或者make_shared<T>)
2、不要把this给shared_ptr
3、相互包含的对象，如果都是用shared_ptr管理，则两个对象中的资源都不会释放。用week_ptr打断循环或者显式清理
4、不要在函数实参创建shared_ptr
5、不是new或者make_shared的对象给shared_ptr比较危险
6、想要使用shared_from_this()必须继承enable_shared_from_this，且对象必须是new出来的
	class Y: public boost::enable_shared_from_this<Y>
	{
		boost::shared_ptr<Y> GetSelf()
		{
			return shared_from_this();
		}
	}

	Y y;
	boost::shared_ptr<Y> p = y.GetSelf();     // 对象不是new出来的。错误

	Y* y = new Y();
	boost::shared_ptr<Y> p = y->GetSelf();	  // 任可能导致奔溃，非正常途径创建的shared_ptr

	boost::shared_ptr<Y> y(new Y());	  // 可行，或者使用make_shared
	boost::shared_ptr<Y> p = y->GetSelf();
7、用shared_ptr构造函数的第三个参数分配器Mallocator<T>()可以减少内存碎片
8、week_ptr使用前尽量使用expired()检查下资源是否还在
9、shared_ptr不要在堆上分配，即不要new
10、尽量不要用get()获取资源，需要类型转换使用专用的方法
11、不要memcpy shared_ptr，引用计数不会增加



week_ptr没有共享资源，他的构造函数不会引起指针引用数增加。配合shared_ptr工作. expired()功能表示被观察的对象不复存在。没有重载操作符，不能操作资源。
week_ptr的lock()可以返回一个shared_ptr且use_count增加





timer类似QTimer
progress_timer提供简单的输出时间功能，计算函数执行时间。即析构会输出时间
progress_display动作执行进度