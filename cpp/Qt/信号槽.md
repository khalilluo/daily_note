信号槽Connect

### 任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数

### 一个信号可以和多个槽相连，这些槽会一个接一个的被调用，但是它们的调用顺序是不确定的。

- Qt::AutoConnection   ： 自动连接：（默认值）如果信号在接收者所依附的线程内发射，则等同于直接连接。如果发射信号的线程和接受者所依附的线程不同，则等同于队列连接 
- Qt::DirectConnection    ：直接连接：当信号发射时，槽函数将直接被调用。无论槽函数所属对象在哪个线程，槽函数都在发射信号的线程内执行。[这种方式不能跨线程传递消息]
-  Qt::QueuedConnection  ：队列连接：当控制权回到接受者所依附线程的事件循环时，槽函数被调用。槽函数在接收者所依附线程执行。[这种方式既可以在线程内传递消息，也可以跨线程传递消息]
- Qt::BlockingQueuedConnection ： 与Qt::QueuedConnection类似，但是发送消息后会阻塞，直到等到关联的slot都被执行。[说明它是专门用来多线程间传递消息的，而且是阻塞的] 不能在同个线程使用
- Qt::UniqueConnection   ：这个标志可以和上述标志通过或OR来结合使用。用于失能已经存在的connection。 



### 槽函数重载时使用QOverload获取对应版本

```cpp
void currentIndexChanged(int index);
void currentIndexChanged(const QString &)

//comboBox信号槽
connect(ui->comboBox_Lang, SIGNAL(currentIndexChanged(int)), this, SLOT(onIndexChanged(int)));

//comboBox信号槽(C++11写法)
connect(ui->comboBox_Lang, QOverload<int>::of(&QComboBox::currentIndexChanged), this, [=](int index){
    QString info = QString("SELECT INDEX: %1").arg(index);
    ui->textEdit_Info->append(info);
});
```

```cpp
// 在thread2Obj中connect,区别是有没有this
connect(thread1Obj1, &Thread1Obj1::signal, [this]{
	// do something
	// 此处是thread1
})

connect(thread1Obj1, &Thread1Obj1::signal, this, [this]{
	// do something
	// 此处是thread2
})
```


## 同步和异步事件

在Qt中，事件可以同步或异步发送。异步事件使用`QCoreApplication::postEvent()`在事件队列中排队，该队列由`QAbstractEventDispatcher`的一个特定于平台的子类管理。同步事件`QCoreApplication::sendEvent()`无需排队。还要注意，异步事件是由事件系统管理的，这意味着它们必须在堆中分配，并且不能被开发人员使用代码删除。

异步事件是线程安全的。实际上，跨线程信号和槽是基于异步事件的。当一个线程中的一个对象向另一个线程中的一个对象发出信号时，假设连接类型是自动的或排队的，那么实际上在线程之间发送了一个事件。当事件在另一个线程中处理时，处理程序代码自动调用槽。

因为Qt中的任何线程都可以有自己的事件循环，所以不要直接从另一个线程调用slot或任何函数来中断事件处理，这一点很重要。使用排队连接或异步事件是安全的。只要接收线程返回到事件循环并开始处理新事件，事件就会进入队列。此外，如果您从工作线程通知GUI线程有新数据可用时，您应该始终异步地执行此操作